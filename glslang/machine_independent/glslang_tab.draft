module glslang.machine_independent.glslang_tab;

const parser_init_t parser_init;
shared static this() { parser_init = new const parser_init_t(); }

void main() {
  import std.stdio;
  
  writeln(parser_init.ntokens);
  writeln(parser_init.nnterms);
  writeln(parser_init.nrules);
  writeln(parser_init.nritems);

  parser_init.print_derives();
}

alias item_number_t = int;

alias rule_number_t = int;
struct rule_t {
  rule_number_t number;
  sym_content_t lhs;
  item_number_t[] rhs;
}

alias symbol_number_t = int;
enum symbol_number_t NUMBER_UNDEFINED = -1;

enum symbol_class_t {
  unknown_sym,
  percent_type_sym,
  token_sym,
  nterm_sym
}

struct sym_content_arg_t {
  symbol_class_t class_;
  symbol_number_t number;
}

class sym_content_t {
  symbol_t symbol;
  symbol_class_t class_;
  symbol_number_t number;

  this(symbol_t s) {
    symbol = s;

    class_ = symbol_class_t.unknown_sym;
    number = NUMBER_UNDEFINED;
  }
}

class symbol_t {
  string tag;
  int order_of_appearance;

  symbol_t alias_;
  bool is_alias;

  sym_content_t content;

  this(string tag) {
    this.tag = tag;
    this.content = new sym_content_t(this);
  }

  void make_alias(symbol_t str) {
    str.content = this.content;
    str.content.symbol = str;
    str.is_alias = true;
    str.alias_ = this;
    this.alias_ = str;
  }
}

class parser_init_t {
  symbol_t[] symbols;
  symbol_t[] symbols_sorted;
  symbol_t[string] symbol_table;

  symbol_t acceptsymbol;

  item_number_t[] ritem;
  int nritems = 0;

  rule_t[] rules;
  rule_number_t nrules = 0;
  rule_t[][][] derives;

  int nnterms = 0;
  int ntokens = 1;
  int nsyms = 0;

  item_index_t[][] kernel_base;
  int[] kernel_size;

  item_index_t[] kernel_items;

  bool[][] fderives;
  item_index_t[] itemset;
  bool[] ruleset;

  this() {
    new gram_init_t(this);
    derives_compute();
    generate_states();
  }

  alias item_index_t = uint;

  void derives_compute() {
    import std.range;

    struct rule_list_t {
      rule_list_t[] next;
      rule_t[] value;
    }

    rule_list_t[][] dset = new rule_list_t[][nnterms];
    rule_list_t[] delts = new rule_list_t[nrules];

    for (rule_number_t r = nrules - 1; r >= 0; --r) {
      symbol_number_t lhs = rules[r].lhs.number;
      rule_list_t[] p = delts[r..$];

      p.front.next = dset[lhs - ntokens];
      p.front.value = rules[r..$];

      dset[lhs - ntokens] = p;
    }

    derives = new rule_t[][][nnterms];
    rule_t[][] q = new rule_t[][nnterms + nrules];

    for (symbol_number_t i = ntokens; i < nsyms; ++i) {
      rule_list_t[] p = dset[i - ntokens];
      derives[i - ntokens] = q;

      while (p) {
        q.front = p.front.value;
        q.popFront;
        p = p.front.next;
      }

      q.front = null;
      q.popFront;
    }
  }

  void print_derives() const {
    import std.range.primitives;
    import std.stdio;

    write("DERIVES\n");

    for (symbol_number_t i = ntokens; i < nsyms; ++i) {
      writef("  %s derives\n", symbols[i].tag);
      foreach (rp; derives[i - ntokens]) {
        if (rp is null) break;
        writef("    %3d ", rp.front.number);
        if (rp.front.rhs.front >= 0)
          foreach (rhsi; rp.front.rhs) {
            if (rhsi < 0) break;
            writef(" %s", symbols[rhsi].tag);
          }
        else
          writef(" %s", cast(dchar) 0x03b5);
        write("\n");
      }
    }

    write("\n\n");
  }

  void generate_states() {
    allocate_storage();
    closure_new(nritems);
  }

  void closure_new(int n) {
    itemset = new item_index_t[n];
    ruleset = new bool[nrules];

    set_fderives();
  }

  void set_fderives() {
    import std.range.primitives;

    bool[] buffer = new bool[nnterms * nrules];
    fderives = new bool[][nnterms];
    {
      size_t j;
      for (size_t i = 0; i < nnterms; i++) {
        j = i + 1;
        fderives[i] = buffer[i * nrules..j * nrules];
      }
    }

    bool[][] firsts;
    set_firsts(firsts);

    for (symbol_number_t i = ntokens; i < nsyms; ++i)
      for (symbol_number_t j = ntokens; j < nsyms; ++j)
        if (firsts[i - ntokens][j - ntokens])
          for (rule_number_t k = 0; derives[j - ntokens][k]; ++k)
            fderives[i - ntokens][derives[j - ntokens][k].front.number] = true;
  }

  void print_fderives() const {
    import std.range.primitives;
    import std.stdio;

    write("FDERIVES\n");

    for (symbol_number_t i = ntokens; i < nsyms; ++i) {
      writef("  %s derives\n", symbols[i].tag);
      foreach (r, flag; fderives[i - ntokens])
        if (flag) {
          writef("    %3d ", r);
          if (rules[r].rhs.front >= 0)
            foreach (rhsi; rules[r].rhs) {
              if (rhsi < 0) break;
              writef(" %s", symbols[rhsi].tag);
            }
          else
            writef(" %s", cast(dchar) 0x03b5);
          write("\n");
        }
    }

    write("\n\n");
  }

  void set_firsts(out bool[][] firsts) {
    import std.range.primitives;

    bool[] buffer = new bool[nnterms * nnterms];
    firsts = new bool[][nnterms];
    {
      size_t j;
      for (size_t i = 0; i < nnterms; i++) {
        j = i + 1;
        firsts[i] = buffer[i * nnterms..j * nnterms];
      }
    }
    
    for (symbol_number_t i = ntokens; i < nsyms; ++i)
      for (symbol_number_t j = 0; derives[i - ntokens][j]; ++j) {
        item_number_t sym = derives[i - ntokens][j].front.rhs.front;
        if(sym >= ntokens)
          firsts[i - ntokens][sym - ntokens] = true;
      }
    
    for (size_t i = 0; i < firsts.length; i++)
      for (size_t j = 0; j < firsts.length; j++)
        if (firsts[j][i])
          for (size_t k = 0; k < firsts[j].length; k++)
            firsts[j][k] = firsts[j][k] || firsts[i][k];

    for (size_t i = 0; i < firsts.length; i++)
      firsts[i][i] = true;
  }

  void print_firsts(in bool[][] firsts) const {
    import std.stdio;

    write("FIRSTS\n");

    for (symbol_number_t i = ntokens; i < nsyms; ++i) {
      writef("  %s firsts\n", symbols[i].tag);
      foreach (j, flag; firsts[i - ntokens])
        if (flag) writef("    %s\n", symbols[j + ntokens].tag);
    }

    write("\n\n");
  }

  void allocate_storage() {
    allocate_itemsets();
  }

  void allocate_itemsets() {
    size_t count = 0;
    size_t[] symbol_count = new size_t[nsyms];

    for (rule_number_t r = 0; r < nrules; ++r)
      for (size_t i = 0; rules[r].rhs[i] >= 0; i++) {
        symbol_number_t sym = rules[r].rhs[i];
        count += 1;
        symbol_count[sym] += 1;
      }

    kernel_base = new item_index_t[][nsyms];
    kernel_items = new item_index_t[count];

    count = 0;
    for (symbol_number_t i = 0; i < nsyms; i++) {
      kernel_base[i] = kernel_items[count..$];
      count += symbol_count[i];
    }

    kernel_size = new int[nsyms];
  }
}

class gram_init_t {
  parser_init_t root;

  symbol_t acceptsymbol;
  symbol_t errtoken;
  symbol_t undeftoken;
  symbol_t eoftoken;

  symbol_list_t grammar;
  symbol_list_t grammar_end;
  symbol_list_t start_symbols;
  symbol_list_t current_rule;
  symbol_list_t previous_rule_end;

  int dummy_count = 0;
  int order_of_appearance = 0;

  class symbol_list_t {
    symbol_t sym;
    symbol_list_t next;

    this(symbol_t sym) {
      this.sym = sym;
    }
  }

  this(parser_init_t r) {
    root = r;

    gram_init_pre();
    token_init();
    nterm_init();
    gram_init_post();
  }

  symbol_t declare_sym(symbol_t sym, symbol_class_t class_) {
    sym.content.class_ = class_;
    sym.order_of_appearance = ++order_of_appearance;
    return sym;
  }

  symbol_t symbol_get(string key) {
    if (key !in root.symbol_table)
      root.symbol_table[key] = new symbol_t(key);
    return root.symbol_table[key];
  }

  symbol_t dummy_symbol_get() {
    import std.format;
    return declare_sym(
      symbol_get(format("$@%d", ++dummy_count)),
      symbol_class_t.nterm_sym
    );
  }

  symbol_list_t grammar_symbol_append(symbol_t sym) {
    symbol_list_t p = new symbol_list_t(sym);

    if (grammar_end)
      grammar_end.next = p;
    else
      grammar = p;

    grammar_end = p;

    if (sym)
      ++root.nritems;

    return p;
  }

  void grammar_start_symbols_add(symbol_list_t syms) {
    start_symbols = syms;
  }

  void grammar_current_rule_begin(symbol_t lhs) {
    ++root.nrules;
    previous_rule_end = grammar_end;

    current_rule = grammar_symbol_append(lhs);

    if (lhs.content.class_ == symbol_class_t.unknown_sym ||
      lhs.content.class_ == symbol_class_t.percent_type_sym) {
      lhs.content.class_ = symbol_class_t.nterm_sym;
    }
  }

  void grammar_current_rule_symbol_append(symbol_t sym) {
    grammar_symbol_append(sym);
  }

  void grammar_current_rule_end() {
    grammar_symbol_append(null);
  }

  void grammar_midrule_action() {
    symbol_t dummy = dummy_symbol_get();
    symbol_list_t midrule = new symbol_list_t(dummy);

    ++root.nrules;
    ++root.nritems;
    
    if (previous_rule_end)
      previous_rule_end.next = midrule;
    else
      grammar = midrule;

    midrule.next = new symbol_list_t(null);
    midrule.next.next = current_rule;

    previous_rule_end = midrule.next;

    grammar_current_rule_symbol_append(dummy);
  }

  void packgram() {
    import std.range.primitives;

    int itemno = 0;
    root.ritem = new item_number_t[root.nritems];

    rule_number_t ruleno = 0;
    root.rules = new rule_t[root.nrules];

    for (symbol_list_t p = grammar; p; p = p.next) {
      symbol_list_t lhs = p;

      root.rules[ruleno].number = ruleno;
      root.rules[ruleno].lhs = lhs.sym.content;
      root.rules[ruleno].rhs = root.ritem[itemno..$];

      size_t rule_length = 0;
      for (p = lhs.next; p.sym; p = p.next) {
        ++rule_length;
        root.ritem[itemno++] = p.sym.content.number;
      }

      root.ritem[itemno++] = -1 - ruleno;
      ++ruleno;
    }
  }

  void gram_init_pre() {
    acceptsymbol = symbol_get("$accept");
    acceptsymbol.order_of_appearance = 0;
    acceptsymbol.content.class_ = symbol_class_t.nterm_sym;
    acceptsymbol.content.number = root.nnterms++;
    root.acceptsymbol = acceptsymbol;

    errtoken = symbol_get("YYerror");
    errtoken.order_of_appearance = 0;
    errtoken.content.class_ = symbol_class_t.token_sym;
    errtoken.content.number = root.ntokens++;
    {
      symbol_t alias_ = symbol_get("error");
      alias_.order_of_appearance = 0;
      alias_.content.class_ = symbol_class_t.token_sym;
      errtoken.make_alias(alias_);
    }

    undeftoken = symbol_get("YYUNDEF");
    undeftoken.order_of_appearance = 0;
    undeftoken.content.class_ = symbol_class_t.token_sym;
    undeftoken.content.number = root.ntokens++;
    {
      symbol_t alias_ = symbol_get("$undefined");
      alias_.order_of_appearance = 0;
      alias_.content.class_ = symbol_class_t.token_sym;
      undeftoken.make_alias(alias_);
    }
  }

  void create_start_rule(symbol_t swtok, symbol_t start) {
    symbol_list_t initial_rule = new symbol_list_t(acceptsymbol);
    symbol_list_t p = initial_rule;
    p.next = new symbol_list_t(start);
    p = p.next;
    p.next = new symbol_list_t(eoftoken);
    p = p.next;
    p.next = new symbol_list_t(null);
    p = p.next;
    p.next = grammar;
    root.nrules += 1;
    root.nritems += 3;
    grammar = initial_rule;
  }

  void gram_init_post() {
    import std.algorithm.sorting;
    import std.array;

    eoftoken = symbol_get("YYEOF");
    eoftoken.order_of_appearance = 0;
    eoftoken.content.class_ = symbol_class_t.token_sym;
    eoftoken.content.number = 0;
    {
      symbol_t alias_ = symbol_get("$end");
      alias_.order_of_appearance = 0;
      alias_.content.class_ = symbol_class_t.token_sym;
      eoftoken.make_alias(alias_);
    }

    symbol_t start = start_symbols.sym;
    create_start_rule(null, start);

    root.symbols_sorted = root.symbol_table.values
      .sort!("a.order_of_appearance < b.order_of_appearance")
      .array;
    foreach (sym; root.symbols_sorted) {
      sym_content_t s = sym.content;

      if (s.number == NUMBER_UNDEFINED)
        s.number = s.class_ == symbol_class_t.token_sym
          ? root.ntokens++ : root.nnterms++;
    }

    root.nsyms = root.ntokens + root.nnterms;
    root.symbols = new symbol_t[root.nsyms];

    foreach (sym; root.symbols_sorted) {
      if (sym.content.class_ == symbol_class_t.nterm_sym)
        sym.content.number += root.ntokens;

      root.symbols[sym.content.number] = sym.content.symbol;
    }

    packgram();
  }

  void compound_statement_init() {
    declare_sym(symbol_get("compound_statement"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("compound_statement"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_BRACE"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_BRACE"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("compound_statement"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_BRACE"));
    grammar_midrule_action();
    grammar_current_rule_symbol_append(symbol_get("statement_list"));
    grammar_midrule_action();
    grammar_current_rule_symbol_append(symbol_get("RIGHT_BRACE"));
    grammar_current_rule_end();
  }

  void statement_no_new_scope_init() {
    declare_sym(symbol_get("statement_no_new_scope"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("statement_no_new_scope"));
    grammar_current_rule_symbol_append(symbol_get("compound_statement_no_new_scope"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("statement_no_new_scope"));
    grammar_current_rule_symbol_append(symbol_get("simple_statement"));
    grammar_current_rule_end();
  }

  void statement_scoped_init() {
    declare_sym(symbol_get("statement_scoped"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("statement_scoped"));
    grammar_midrule_action();
    grammar_current_rule_symbol_append(symbol_get("compound_statement"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("statement_scoped"));
    grammar_midrule_action();
    grammar_current_rule_symbol_append(symbol_get("simple_statement"));
    grammar_current_rule_end();
  }

  void compound_statement_no_new_scope_init() {
    declare_sym(symbol_get("compound_statement_no_new_scope"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("compound_statement_no_new_scope"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_BRACE"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_BRACE"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("compound_statement_no_new_scope"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_BRACE"));
    grammar_current_rule_symbol_append(symbol_get("statement_list"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_BRACE"));
    grammar_current_rule_end();
  }

  void statement_list_init() {
    declare_sym(symbol_get("statement_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("statement_list"));
    grammar_current_rule_symbol_append(symbol_get("statement"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("statement_list"));
    grammar_current_rule_symbol_append(symbol_get("statement_list"));
    grammar_current_rule_symbol_append(symbol_get("statement"));
    grammar_current_rule_end();
  }

  void expression_statement_init() {
    declare_sym(symbol_get("expression_statement"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("expression_statement"));
    grammar_current_rule_symbol_append(symbol_get("SEMICOLON"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("expression_statement"));
    grammar_current_rule_symbol_append(symbol_get("expression"));
    grammar_current_rule_symbol_append(symbol_get("SEMICOLON"));
    grammar_current_rule_end();
  }

  void selection_statement_init() {
    declare_sym(symbol_get("selection_statement"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("selection_statement"));
    grammar_current_rule_symbol_append(symbol_get("selection_statement_nonattributed"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("selection_statement"));
    grammar_current_rule_symbol_append(symbol_get("attribute"));
    grammar_current_rule_symbol_append(symbol_get("selection_statement_nonattributed"));
    grammar_current_rule_end();
  }

  void selection_rest_statement_init() {
    declare_sym(symbol_get("selection_rest_statement"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("selection_rest_statement"));
    grammar_current_rule_symbol_append(symbol_get("statement_scoped"));
    grammar_current_rule_symbol_append(symbol_get("ELSE"));
    grammar_current_rule_symbol_append(symbol_get("statement_scoped"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("selection_rest_statement"));
    grammar_current_rule_symbol_append(symbol_get("statement_scoped"));
    grammar_current_rule_end();
  }

  void condition_init() {
    declare_sym(symbol_get("condition"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("condition"));
    grammar_current_rule_symbol_append(symbol_get("expression"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("condition"));
    grammar_current_rule_symbol_append(symbol_get("fully_specified_type"));
    grammar_current_rule_symbol_append(symbol_get("IDENTIFIER"));
    grammar_current_rule_symbol_append(symbol_get("EQUAL"));
    grammar_current_rule_symbol_append(symbol_get("initializer"));
    grammar_current_rule_end();
  }

  void switch_statement_init() {
    declare_sym(symbol_get("switch_statement"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("switch_statement"));
    grammar_current_rule_symbol_append(symbol_get("switch_statement_nonattributed"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("switch_statement"));
    grammar_current_rule_symbol_append(symbol_get("attribute"));
    grammar_current_rule_symbol_append(symbol_get("switch_statement_nonattributed"));
    grammar_current_rule_end();
  }

  void switch_statement_list_init() {
    declare_sym(symbol_get("switch_statement_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("switch_statement_list"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("switch_statement_list"));
    grammar_current_rule_symbol_append(symbol_get("statement_list"));
    grammar_current_rule_end();
  }

  void case_label_init() {
    declare_sym(symbol_get("case_label"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("case_label"));
    grammar_current_rule_symbol_append(symbol_get("CASE"));
    grammar_current_rule_symbol_append(symbol_get("expression"));
    grammar_current_rule_symbol_append(symbol_get("COLON"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("case_label"));
    grammar_current_rule_symbol_append(symbol_get("DEFAULT"));
    grammar_current_rule_symbol_append(symbol_get("COLON"));
    grammar_current_rule_end();
  }

  void iteration_statement_init() {
    declare_sym(symbol_get("iteration_statement"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("iteration_statement"));
    grammar_current_rule_symbol_append(symbol_get("iteration_statement_nonattributed"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("iteration_statement"));
    grammar_current_rule_symbol_append(symbol_get("attribute"));
    grammar_current_rule_symbol_append(symbol_get("iteration_statement_nonattributed"));
    grammar_current_rule_end();
  }

  void for_init_statement_init() {
    declare_sym(symbol_get("for_init_statement"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("for_init_statement"));
    grammar_current_rule_symbol_append(symbol_get("expression_statement"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("for_init_statement"));
    grammar_current_rule_symbol_append(symbol_get("declaration_statement"));
    grammar_current_rule_end();
  }

  void conditionopt_init() {
    declare_sym(symbol_get("conditionopt"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("conditionopt"));
    grammar_current_rule_symbol_append(symbol_get("condition"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("conditionopt"));
    grammar_current_rule_end();
  }

  void for_rest_statement_init() {
    declare_sym(symbol_get("for_rest_statement"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("for_rest_statement"));
    grammar_current_rule_symbol_append(symbol_get("conditionopt"));
    grammar_current_rule_symbol_append(symbol_get("SEMICOLON"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("for_rest_statement"));
    grammar_current_rule_symbol_append(symbol_get("conditionopt"));
    grammar_current_rule_symbol_append(symbol_get("SEMICOLON"));
    grammar_current_rule_symbol_append(symbol_get("expression"));
    grammar_current_rule_end();
  }

  void translation_unit_init() {
    declare_sym(symbol_get("translation_unit"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("translation_unit"));
    grammar_current_rule_symbol_append(symbol_get("external_declaration"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("translation_unit"));
    grammar_current_rule_symbol_append(symbol_get("translation_unit"));
    grammar_current_rule_symbol_append(symbol_get("external_declaration"));
    grammar_current_rule_end();
  }

  void external_declaration_init() {
    declare_sym(symbol_get("external_declaration"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("external_declaration"));
    grammar_current_rule_symbol_append(symbol_get("function_definition"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("external_declaration"));
    grammar_current_rule_symbol_append(symbol_get("declaration"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("external_declaration"));
    grammar_current_rule_symbol_append(symbol_get("SEMICOLON"));
    grammar_current_rule_end();
  }

  void attribute_list_init() {
    declare_sym(symbol_get("attribute_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("attribute_list"));
    grammar_current_rule_symbol_append(symbol_get("single_attribute"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("attribute_list"));
    grammar_current_rule_symbol_append(symbol_get("attribute_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("single_attribute"));
    grammar_current_rule_end();
  }

  void single_attribute_init() {
    declare_sym(symbol_get("single_attribute"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("single_attribute"));
    grammar_current_rule_symbol_append(symbol_get("IDENTIFIER"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("single_attribute"));
    grammar_current_rule_symbol_append(symbol_get("IDENTIFIER"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_PAREN"));
    grammar_current_rule_symbol_append(symbol_get("constant_expression"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_PAREN"));
    grammar_current_rule_end();
  }

  void spirv_requirements_list_init() {
    declare_sym(symbol_get("spirv_requirements_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_requirements_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_requirements_parameter"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_requirements_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_requirements_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("spirv_requirements_parameter"));
    grammar_current_rule_end();
  }

  void spirv_requirements_parameter_init() {
    declare_sym(symbol_get("spirv_requirements_parameter"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_requirements_parameter"));
    grammar_current_rule_symbol_append(symbol_get("IDENTIFIER"));
    grammar_current_rule_symbol_append(symbol_get("EQUAL"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_BRACKET"));
    grammar_current_rule_symbol_append(symbol_get("spirv_extension_list"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_BRACKET"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_requirements_parameter"));
    grammar_current_rule_symbol_append(symbol_get("IDENTIFIER"));
    grammar_current_rule_symbol_append(symbol_get("EQUAL"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_BRACKET"));
    grammar_current_rule_symbol_append(symbol_get("spirv_capability_list"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_BRACKET"));
    grammar_current_rule_end();
  }

  void spirv_extension_list_init() {
    declare_sym(symbol_get("spirv_extension_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_extension_list"));
    grammar_current_rule_symbol_append(symbol_get("STRING_LITERAL"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_extension_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_extension_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("STRING_LITERAL"));
    grammar_current_rule_end();
  }

  void spirv_capability_list_init() {
    declare_sym(symbol_get("spirv_capability_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_capability_list"));
    grammar_current_rule_symbol_append(symbol_get("INTCONSTANT"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_capability_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_capability_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("INTCONSTANT"));
    grammar_current_rule_end();
  }

  void spirv_execution_mode_parameter_list_init() {
    declare_sym(symbol_get("spirv_execution_mode_parameter_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_execution_mode_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_execution_mode_parameter"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_execution_mode_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_execution_mode_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("spirv_execution_mode_parameter"));
    grammar_current_rule_end();
  }

  void spirv_execution_mode_id_parameter_list_init() {
    declare_sym(symbol_get("spirv_execution_mode_id_parameter_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_execution_mode_id_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("constant_expression"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_execution_mode_id_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_execution_mode_id_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("constant_expression"));
    grammar_current_rule_end();
  }

  void spirv_storage_class_qualifier_init() {
    declare_sym(symbol_get("spirv_storage_class_qualifier"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_storage_class_qualifier"));
    grammar_current_rule_symbol_append(symbol_get("SPIRV_STORAGE_CLASS"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_PAREN"));
    grammar_current_rule_symbol_append(symbol_get("INTCONSTANT"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_PAREN"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_storage_class_qualifier"));
    grammar_current_rule_symbol_append(symbol_get("SPIRV_STORAGE_CLASS"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_PAREN"));
    grammar_current_rule_symbol_append(symbol_get("spirv_requirements_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("INTCONSTANT"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_PAREN"));
    grammar_current_rule_end();
  }

  void spirv_decorate_parameter_list_init() {
    declare_sym(symbol_get("spirv_decorate_parameter_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_decorate_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_decorate_parameter"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_decorate_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_decorate_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("spirv_decorate_parameter"));
    grammar_current_rule_end();
  }

  void spirv_decorate_string_parameter_list_init() {
    declare_sym(symbol_get("spirv_decorate_string_parameter_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_decorate_string_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("STRING_LITERAL"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_decorate_string_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_decorate_string_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("STRING_LITERAL"));
    grammar_current_rule_end();
  }

  void spirv_type_parameter_list_init() {
    declare_sym(symbol_get("spirv_type_parameter_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_type_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_type_parameter"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_type_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_type_parameter_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("spirv_type_parameter"));
    grammar_current_rule_end();
  }

  void spirv_type_parameter_init() {
    declare_sym(symbol_get("spirv_type_parameter"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_type_parameter"));
    grammar_current_rule_symbol_append(symbol_get("constant_expression"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_type_parameter"));
    grammar_current_rule_symbol_append(symbol_get("type_specifier_nonarray"));
    grammar_current_rule_end();
  }

  void spirv_instruction_qualifier_init() {
    declare_sym(symbol_get("spirv_instruction_qualifier"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_instruction_qualifier"));
    grammar_current_rule_symbol_append(symbol_get("SPIRV_INSTRUCTION"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_PAREN"));
    grammar_current_rule_symbol_append(symbol_get("spirv_instruction_qualifier_list"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_PAREN"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_instruction_qualifier"));
    grammar_current_rule_symbol_append(symbol_get("SPIRV_INSTRUCTION"));
    grammar_current_rule_symbol_append(symbol_get("LEFT_PAREN"));
    grammar_current_rule_symbol_append(symbol_get("spirv_requirements_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("spirv_instruction_qualifier_list"));
    grammar_current_rule_symbol_append(symbol_get("RIGHT_PAREN"));
    grammar_current_rule_end();
  }

  void spirv_instruction_qualifier_list_init() {
    declare_sym(symbol_get("spirv_instruction_qualifier_list"), symbol_class_t.nterm_sym);

    grammar_current_rule_begin(symbol_get("spirv_instruction_qualifier_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_instruction_qualifier_id"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_instruction_qualifier_list"));
    grammar_current_rule_symbol_append(symbol_get("spirv_instruction_qualifier_list"));
    grammar_current_rule_symbol_append(symbol_get("COMMA"));
    grammar_current_rule_symbol_append(symbol_get("spirv_instruction_qualifier_id"));
    grammar_current_rule_end();
  }

  void spirv_instruction_qualifier_id_init() {
    declare_sym(symbol_get("spirv_instruction_qualifier_id"), symbol_class_t.nterm_sym);
    
    grammar_current_rule_begin(symbol_get("spirv_instruction_qualifier_id"));
    grammar_current_rule_symbol_append(symbol_get("IDENTIFIER"));
    grammar_current_rule_symbol_append(symbol_get("EQUAL"));
    grammar_current_rule_symbol_append(symbol_get("STRING_LITERAL"));
    grammar_current_rule_end();

    grammar_current_rule_begin(symbol_get("spirv_instruction_qualifier_id"));
    grammar_current_rule_symbol_append(symbol_get("IDENTIFIER"));
    grammar_current_rule_symbol_append(symbol_get("EQUAL"));
    grammar_current_rule_symbol_append(symbol_get("INTCONSTANT"));
    grammar_current_rule_end();
  }
}